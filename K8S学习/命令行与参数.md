# 1. dockerfile相关
|关键字|	用途说明|
|---|---|
|FROM	|指定基础镜像（必须是 Dockerfile 的第一条指令），如 FROM ubuntu:20.04|
|WORKDIR	|设置后续指令的工作目录（类似 cd，避免使用 RUN cd）|
|COPY	|将宿主机文件 / 目录复制到镜像中（仅复制文件，不解析变量或通配符逻辑）|
|ADD	|类似 COPY，但支持自动解压压缩包、下载 URL 文件（推荐优先用 COPY）|
|RUN	|在镜像构建阶段执行命令（如安装依赖），每一行 RUN 会创建一个镜像层|
|ENV	|设置环境变量（构建和容器运行时均有效），如 ENV JAVA_HOME /usr/lib/jvm|
|EXPOSE	|声明容器运行时对外暴露的端口（仅为文档说明，不实际映射）|
|CMD	|定义容器启动时执行的命令（容器启动后仅执行一次，可被 docker run 覆盖）|
|ENTRYPOINT	|定义容器的入口程序（与 CMD 配合使用，docker run 不可完全覆盖）|
|VOLUME	|声明匿名数据卷（避免容器内数据丢失，可在运行时挂载宿主机目录）|
|ARG	|定义构建时的临时变量（仅在 docker build 时有效，运行时不可用）|

- 示例
```
# 基础镜像：使用官方OpenJDK 17（Alpine版本体积更小）
FROM openjdk:17-jdk-slim

# 构建参数：应用JAR包名称（可在构建时通过--build-arg指定）
ARG JAR_FILE=target/*.jar

# 设置工作目录（后续命令在此目录执行）
WORKDIR /app

# 将宿主机的JAR包复制到镜像的/app目录下
COPY ${JAR_FILE} app.jar

# 设置环境变量：JVM参数（运行时生效）
ENV JAVA_OPTS="-Xms512m -Xmx1024m"

# 声明容器暴露的端口（Spring Boot默认8080）
EXPOSE 8080

# 容器启动命令：执行Java应用
# ENTRYPOINT 定义入口，CMD 提供默认参数（可被docker run覆盖）
ENTRYPOINT ["sh", "-c", "java ${JAVA_OPTS} -jar app.jar"]
    
```
- 后续的运行
```
# 构建镜像（假设已通过Maven打包好JAR）
docker build -t my-spring-app:1.0 .

# 运行容器（映射8080端口，覆盖环境变量）
docker run -d -p 8080:8080 -e JAVA_OPTS="-Xms256m -Xmx512m" --name my-app my-spring-app:1.0
```

- 关于CMD和ENTRYPOINT的区别
1. 核心区别：是否可被覆盖
   - CMD：定义容器启动时的默认命令或参数，可以被 docker run 命令后的参数直接覆盖。
   - ENTRYPOINT：定义容器的固定入口程序，docker run 命令后的参数会被当作参数传递给 ENTRYPOINT，而不是覆盖它。
2. ENTRYPOINT + CMD 组合使用（最常用）
   - 假如使用如下dockerfile
```
# Dockerfile
FROM alpine
ENTRYPOINT ["echo", "Hello, "]  # 固定入口
CMD ["default!"]                # 默认参数
```
   - 正常运行不带参数
```
docker run my-image
# 输出：Hello, default! （ENTRYPOINT + CMD 组合）
```
   - 带参数
```
docker run my-image custom!
# 输出：Hello, custom! （新参数替换了CMD的默认值）
```

# K8S的命令行与参数
在 Kubernetes 中，容器的启动命令（Command）和参数（Arguments）对应 Docker 中的 ENTRYPOINT 和 CMD，用于定义容器启动时执行的程序及参数。K8s 允许在 Pod 配置中覆盖 Dockerfile 中定义的命令和参数，提供了更灵活的配置方式。

|Docker 概念	|K8s 配置字段	|作用说明|
|---|---|---|
|ENTRYPOINT	|spec.containers.command	|容器的入口命令（固定程序），对应 Docker 的 ENTRYPOINT|
|CMD	|spec.containers.args	|入口命令的参数，对应 Docker 的 CMD，可被 K8s 配置覆盖|

- 具体表现和示例
1. Dockerfile 定义了默认命令和参数
```dockerfile
FROM alpine
ENTRYPOINT ["echo", "Hello, "]  # 入口命令
CMD ["Docker!"]                 # 默认参数
# 构建镜像 my-image 后，默认启动行为是执行 echo "Hello, Docker!"。
```

2. K8s 中不覆盖任何配置
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
  - name: demo-container
    image: my-image  # 使用上述 Dockerfile 构建的镜像
# 启动后，容器执行命令：echo "Hello, Docker!"，输出 Hello, Docker!。
```

3. K8s 覆盖参数（args）
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
  - name: demo-container
    image: my-image
    args: ["Kubernetes!"]  # 覆盖默认参数
# 启动后，容器执行命令：echo "Hello, Kubernetes!"（ENTRYPOINT 不变，仅替换 CMD），输出 Hello, Kubernetes!
```

4. K8s 覆盖命令（command）和参数（args）
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: demo-pod
spec:
  containers:
  - name: demo-container
    image: my-image
    command: ["echo", "Welcome to"]  # 覆盖入口命令
    args: ["K8s!"]                   # 新参数
# 启动后，容器执行命令：echo "Welcome to K8s!"，输出 Welcome to K8s!
```

- 关键特性
  - 优先级：K8s Pod 配置中的 command 和 args 优先级高于 Dockerfile 中的 ENTRYPOINT 和 CMD。
  - 灵活性：可根据不同环境（开发 / 测试 / 生产）通过 args 动态调整参数，无需重新构建镜像。
  - 调试场景：临时修改 command 为交互命令（如 ["sh"]），方便进入容器排查问题